/*
Реализовать конкурентную запись данных в map.
*/

package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := &sync.WaitGroup{} // создаем ссылку на wait group
	m := make(map[int]int)
	var mutex sync.Mutex // создаем мьютекс

	for i := 0; i < 10; i++ {
		wg.Add(1) // добавляем воркер, кладем горутину в wait-группу, счетчик - 1
		go func(i int) {
			defer wg.Done() // отложенный вызов функции, уменьшающий счетчик на 1 (выполнится при выходе из функции)
			mutex.Lock()    // захватываем мьютекс
			m[i] = i        // пишем в мапу; критическая секция, защищенная мьютексами
			mutex.Unlock()  // освобождаем мьютекс
		}(i)
	}

	wg.Wait() // ожидаем, пока счетчик не станет 0

	for i := 0; i < 10; i++ {
		fmt.Println(i, ":", m[i]) // проверка того, что в мапу все записалось
	}
}

/*
	Deadlock в мапе может произойти, если больше одной горутины
	одновременно пытаются изменить один и тот же ключ в мапе.
	Чтобы избежать этого, я использовала один из примитивом синхронизации -
	мьютекс. Когда одна горутина блокирует мьютекс, другая ждет, пока
	он не будет разблокирован. Мьютексы защищают критическую секцию - участок кода,
	доступ к которому может быть предоставлен только одному потоку одновременно.
*/
